#include "Arduino.h"
/**************
 *  numeric Dimmer  ( using robodyn dimmer = 
 *  **************
 *  Upgraded By Cyril Poissonnier 2020
 * 
  *    
 * 
 *  ---------------------- OUTPUT & INPUT Pin table ---------------------
 *  +---------------+-------------------------+-------------------------+
 *  |   Board       | INPUT Pin               | OUTPUT Pin              |
 *  |               | Zero-Cross              |                         |
 *  +---------------+-------------------------+-------------------------+
 *  | Lenardo       | D7 (NOT CHANGABLE)      | D0-D6, D8-D13           |
 *  +---------------+-------------------------+-------------------------+
 *  | Mega          | D2 (NOT CHANGABLE)      | D0-D1, D3-D70           |
 *  +---------------+-------------------------+-------------------------+
 *  | Uno           | D2 (NOT CHANGABLE)      | D0-D1, D3-D20           |
 *  +---------------+-------------------------+-------------------------+
 *  | ESP8266       | D1(IO5),    D2(IO4),    | D0(IO16),   D1(IO5),    |
 *  |               | D5(IO14),   D6(IO12),   | D2(IO4),    D5(IO14),   |
 *  |               | D7(IO13),   D8(IO15),   | D6(IO12),   D7(IO13),   |
 *  |               |                         | D8(IO15)                |
 *  +---------------+-------------------------+-------------------------+
 *  | ESP32         | 4(GPI36),   6(GPI34),   | 8(GPO32),   9(GP033),   |
 *  |               | 5(GPI39),   7(GPI35),   | 10(GPIO25), 11(GPIO26), |
 *  |               | 8(GPO32),   9(GP033),   | 12(GPIO27), 13(GPIO14), |
 *  |               | 10(GPI025), 11(GPIO26), | 14(GPIO12), 16(GPIO13), |
 *  |               | 12(GPIO27), 13(GPIO14), | 23(GPIO15), 24(GPIO2),  |
 *  |               | 14(GPIO12), 16(GPIO13), | 25(GPIO0),  26(GPIO4),  |
 *  |               | 21(GPIO7),  23(GPIO15), | 27(GPIO16), 28(GPIO17), |
 *  |               | 24(GPIO2),  25(GPIO0),  | 29(GPIO5),  30(GPIO18), |
 *  |               | 26(GPIO4),  27(GPIO16), | 31(GPIO19), 33(GPIO21), |
 *  |               | 28(GPIO17), 29(GPIO5),  | 34(GPIO3),  35(GPIO1),  |
 *  |               | 30(GPIO18), 31(GPIO19), | 36(GPIO22), 37(GPIO23), |
 *  |               | 33(GPIO21), 35(GPIO1),  |                         |
 *  |               | 36(GPIO22), 37(GPIO23), |                         |
 *  +---------------+-------------------------+-------------------------+
 *  | Arduino M0    | D7 (NOT CHANGABLE)      | D0-D6, D8-D13           |
 *  | Arduino Zero  |                         |                         |
 *  +---------------+-------------------------+-------------------------+
 *  | Arduino Due   | D0-D53                  | D0-D53                  |
 *  +---------------+-------------------------+-------------------------+
 *  | STM32         | PA0-PA15,PB0-PB15       | PA0-PA15,PB0-PB15       |
 *  | Black Pill    | PC13-PC15               | PC13-PC15               |
 *  | BluePill      |                         |                         |
 *  | Etc...        |                         |                         |
 *  +---------------+-------------------------+-------------------------+
 *  
 *  
 *  Work for dimmer on Domoticz or Web command :
 *  http://URL/?POWER=XX 
 *  0 -> 99 
 *  more than 99 = 99  
 *    
 *  Update 2019 04 28 
 *  correct issue full power for many seconds at start 
 *  Update 2020 01 13 
 *  Version 2 with cute web interface
 *  V2.1    with temperature security ( dallas 18b20 ) 
 *          MQTT to Domoticz for temp 
 */




/***************************
 * Librairy
 **************************/

// time librairy   
//#include <NTPClient.h>
// Dimmer librairy 
#include <Arduino.h>
#include <RBDdimmer.h>   /// the corrected librairy  in RBDDimmer-master-corrected.rar , the original has a bug
// Web services
// #include <ESP8266WiFi.h> // décalé avec la condition ESP32
#include <ESPAsyncWiFiManager.h>    
// #include <ESPAsyncTCP.h> // décalé avec la condition ESP32
#include <ESPAsyncWebServer.h>
// #include <ESP8266HTTPClient.h> // décalé avec la condition ESP32
// File System
//#include <fs.h>
// #include <LittleFS.h> // décalé avec la condition ESP32
#include <Wire.h>  // Only needed for Arduino 1.6.5 and earlier
#include <ArduinoJson.h> // ArduinoJson : https://github.com/bblanchon/ArduinoJson
// ota mise à jour sans fil
#include <AsyncElegantOTA.h>
// Dallas 18b20
#include <OneWire.h>
#include <DallasTemperature.h>
//mqtt
#include <PubSubClient.h>
/// config
#include "config/config.h"
#include "config/enums.h"
#include "function/web.h"
#include "function/ha.h"
#include "function/littlefs.h" 
#include "function/mqtt.h"


#ifdef ESP32
// Web services
  #include "WiFi.h"
  #include <AsyncTCP.h>
  #include "HTTPClient.h"
// File System
  #include <FS.h>
  #include "SPIFFS.h"
  #define LittleFS SPIFFS // Fonctionne, mais est-ce correct? 
#else
// Web services
  #include <ESP8266WiFi.h>
  #include <ESPAsyncTCP.h>
  #include <ESP8266HTTPClient.h> 
// File System
  #include <LittleFS.h>
#endif

/***************************
 * Begin Settings
 **************************/

// WIFI
// At first launch, create wifi network 'dimmer'  ( pwd : dimmer ) 

//***********************************
//************* Gestion du serveur WEB
//***********************************
// Create AsyncWebServer object on port 80
WiFiClient domotic_client;
// mqtt
void Mqtt_send_DOMOTICZ(String idx, String value);
PubSubClient client(domotic_client);


//AsyncWebServer server(80);
DNSServer dns;
HTTPClient http;

void reconnect();
//void Mqtt_HA_hello();
void child_communication(int delest_power);

//void mqtt_HA(String sensor_temp, String sensor_dimmer);

void callback(char* Subscribedtopic, byte* message, unsigned int length) ;

//***********************************
//************* Time
//***********************************
//const long utcOffsetInSeconds = 3600;
//char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
//WiFiUDP ntpUDP;
//NTPClient timeClient(ntpUDP, "pool.ntp.org", utcOffsetInSeconds);
int timesync = 0; 
int timesync_refresh = 120; 

// *************************************

//#define USE_SERIAL  SerialUSB //Serial for boards whith USB serial port
#define USE_SERIAL  Serial

//***********************************
//************* Dallas
//***********************************
void dallaspresent ();
float CheckTemperature(String label, byte deviceAddress[12]);
#define TEMPERATURE_PRECISION 10
void dallaspresent ();
float CheckTemperature(String label, byte deviceAddress[12]);

////////////////////////////////////
///     AP MODE 
/////////////////////////////////

String routeur="PV-ROUTER";
bool AP = false; 
bool discovery_temp;
String dimmername ="";

OneWire  ds(ONE_WIRE_BUS);  //  (a 4.7K resistor is necessary - 5.7K work with 3.3 ans 5V power)
DallasTemperature sensors(&ds);
DeviceAddress insideThermometer;

  byte i;
  byte present = 0;
  byte type_s;
  byte data[12];
  byte addr[8];
  //float celsius = 0.00;
  float previous_celsius = 0.00;
  byte security = 0;
  int refresh = 600; // de 60 à 600, environ 1 fois / minute
  int refreshcount = 0; 

/***************************
 * End Settings
 **************************/

//***********************************
//************* Gestion de la configuration
//***********************************

Config config; 
Mqtt mqtt_config; 
System sysvar;

String getmqtt(); 
void savemqtt(const char *filename, const Mqtt &mqtt_config);
String stringbool(bool mybool);
String getServermode(String Servermode);
String switchstate(int state);

String loginit; 
String logs="197}11}1"; 
String getlogs(); 

char buffer[1024];

//AsyncWiFiManager wifiManager(&server,&dns);

/// création des sensors
MQTT device_dimmer; 
MQTT device_temp; 

/// création des switchs
MQTT device_relay1;
MQTT device_relay2;
MQTT device_dimmer_on_off;

/// création des button
MQTT device_dimmer_save;

/// création number
MQTT device_dimmer_starting_pow; 
MQTT device_dimmer_maxtemp;
MQTT device_dimmer_minpow;
MQTT device_dimmer_maxpow;

/// création select
MQTT device_dimmer_child_mode;

/// création binary_sensor
MQTT device_dimmer_alarm_temp;
MQTT device_cooler;



/***************************
 * init Dimmer5
 **************************/

dimmerLamp dimmer(outputPin, zerocross); //initialise port for dimmer for ESP8266, ESP32, Arduino due boards
#ifdef outputPin2
 dimmerLamp dimmer2(outputPin2, zerocross); //initialise port for dimmer2 for ESP8266, ESP32, Arduino due boards
#endif


int outVal = 0;

    //***********************************
    //************* function web 5
    //***********************************


unsigned long Timer_Cooler;


/*String resetwifi() {
  wifiManager.resetSettings();
  String configweb;  
  configweb = "reset wifi information" ;
  return String(configweb);
}*/

/// fonction pour mettre en pause ou allumer le dimmer 
void dimmer_on()
{
  if (dimmer.getState()==0) {
    dimmer.setState(ON);
    logs +="Dimmer On\r\n"; 
    delay(50);
    }
  #ifdef outputPin2
    if (dimmer2.getState()==0) {
      dimmer2.setState(ON);
      logs +="Dimmer2 On\r\n"; 
      delay(50);
    }  
  #endif
}

void dimmer_off()
{
  if (dimmer.getState()==1) {
    dimmer.setPower(0);
    dimmer.setState(OFF);
    logs +="Dimmer Off\r\n"; 
    delay(50);
    }
  #ifdef outputPin2
    dimmer2.setPower(0);
    dimmer2.setState(OFF);
    logs +="Dimmer2 Off\r\n"; 
    delay(50);
  #endif
}




    //***********************************
    //************* Setup 
    //***********************************

void setup() {
  Serial.begin(115200);
   
  /// Correction issue full power at start
  pinMode(outputPin, OUTPUT); 
  #ifdef outputPin2
    pinMode(outputPin2, OUTPUT); 
  #endif

  //digitalWrite(outputPin, LOW);
  
  // relay
  // #ifdef STANDALONE
  // pinMode(RELAY1, OUTPUT);
  // pinMode(RELAY2, OUTPUT);
  // digitalWrite(RELAY1, LOW);
  // digitalWrite(RELAY2, LOW);
  // #endif
  #ifdef RELAY1 // permet de rajouter les relais en ne modifiant que config.h, et pas seulement en STANDALONE
    pinMode(RELAY1, OUTPUT);
    digitalWrite(RELAY1, LOW);
  #endif
  #ifdef RELAY2 // permet de rajouter les relais en ne modifiant que config.h
    pinMode(RELAY2, OUTPUT);
    digitalWrite(RELAY2, LOW);
  #endif


  // cooler init
  pinMode(COOLER, OUTPUT); 
  digitalWrite(COOLER, LOW);

  //démarrage file system
  LittleFS.begin();
  Serial.println("Demarrage file System");
  loginit +="start filesystem\r\n"; 
  // configuration dimmer
  dimmer.begin(NORMAL_MODE, ON); //dimmer initialisation: name.begin(MODE, STATE) 
  #ifdef outputPin2
    dimmer2.begin(NORMAL_MODE, ON); //dimmer initialisation: name.begin(MODE, STATE) 
  #endif
  ///// correction bug nouveau dimmer...  et config
 
  
  #ifdef POWERSUPPLY2022  
  /// correct bug board
  dimmer.setState(ON);
  
  pinMode(GND_PIN, OUTPUT);  /// board bug
  digitalWrite(GND_PIN, 0);  /// board bug with pin 16 

  pinMode(POS_PIN, OUTPUT); 
  digitalWrite(POS_PIN, 1);
  #endif

    
  dimmer.setPower(outVal); // Pourquoi créer outVal alors qu'on utilise "puissance" ailleurs? 
  #ifdef outputPin2
    dimmer2.setPower(outVal); 
  #endif

  
  USE_SERIAL.println("Dimmer Program is starting...");

      //***********************************
    //************* Setup -  récupération du fichier de configuration
    //***********************************
  #ifndef ESP32
    ESP.getResetReason();
  #endif
  // Should load default config if run for the first time
  Serial.println(F("Loading configuration..."));
  loginit +="load config\r\n"; 
  loadConfiguration(filename_conf, config);

  // Create configuration file
  Serial.println(F("Saving configuration..."));
  loginit +="apply config\r\n"; 
  saveConfiguration(filename_conf, config);

  loadmqtt(mqtt_conf, mqtt_config);
 
  
    //***********************************
    //************* Setup - Connexion Wifi
    //***********************************
  Serial.print("start Wifiautoconnect");
  loginit +="start Wifiautoconnect\r\n"; 
  wifiManager.autoConnect("dimmer");
  Serial.print("end Wifiautoconnect");

  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }


  //Si connexion affichage info dans console
  Serial.println("");
  Serial.print("Connection ok sur le reseau :  ");
 
  Serial.print("IP address: ");

  Serial.println(WiFi.localIP()); 
  #ifndef ESP32
    Serial.println(ESP.getResetReason());
  #endif
  //// AP MODE 
  if ( routeur.compareTo(WiFi.SSID().substring(0,9)) == 0 ) {
      AP = true; 
  }


    //***********************************
    //************* Setup - OTA 
    //***********************************
    AsyncElegantOTA.begin(&server);    // Start ElegantOTA
   
    //***********************************
    //************* Setup - Web pages
    //***********************************
  //server.serveStatic("/css/", LittleFS, "/css/");
  //.setAuthentication("user", "pass");

  //chargement des url des pages
  call_pages();

  dimmername = WiFi.macAddress().substring(12,14)+ WiFi.macAddress().substring(15,17); 


    //***********************************
    //************* Setup -  demarrage du webserver et affichage de l'oled
    //***********************************
  Serial.println("start server");
  server.begin(); 
    
  Serial.println("start 18b20");
  sensors.begin();
    
  /// recherche d'une sonde dallas
  dallaspresent();
  if (config.HA || config.JEEDOM) {
    /// création des sensors
    device_dimmer.Set_name("Puissance");
    device_dimmer.Set_object_id("power");
    device_dimmer.Set_unit_of_meas("%");
    device_dimmer.Set_stat_cla("measurement");
    device_dimmer.Set_dev_cla("power_factor"); // fix is using native unit of measurement '%' which is not a valid unit for the device class ('power') it is using
    device_dimmer.Set_icon("mdi:percent");
    device_dimmer.Set_entity_type("sensor");
    device_dimmer.Set_retain_flag(true);
    // device_dimmer.Set_expire_after(true);

    device_temp.Set_name("Température");
    device_temp.Set_object_id("temperature");
    device_temp.Set_unit_of_meas("°C");
    device_temp.Set_stat_cla("measurement");
    device_temp.Set_dev_cla("temperature");
    device_temp.Set_entity_type("sensor");
    device_temp.Set_retain_flag(true);
    // device_dimmer.Set_expire_after(true);

    
    /// création des switch
    device_relay1.Set_name("Relais 1");
    device_relay1.Set_object_id("relay1");
    device_relay1.Set_entity_type("switch");
    device_relay1.Set_retain_flag(true);
    device_relay1.Set_retain(true);

    device_relay2.Set_name("Relais 2");
    device_relay2.Set_object_id("relay2");
    device_relay2.Set_entity_type("switch");
    device_relay2.Set_retain_flag(true);
    device_relay2.Set_retain(true);


    device_dimmer_on_off.Set_name("Dimmer");
    device_dimmer_on_off.Set_object_id("on_off");
    device_dimmer_on_off.Set_entity_type("switch");
    device_dimmer_on_off.Set_retain_flag(true);
    device_dimmer_on_off.Set_retain(true);

  
    /// création des button
    device_dimmer_save.Set_name("Sauvegarder");
    device_dimmer_save.Set_object_id("save");
    device_dimmer_save.Set_entity_type("button");
    device_dimmer_save.Set_entity_category("config");
    device_dimmer_save.Set_retain_flag(false);

    /// création des number
    device_dimmer_starting_pow.Set_name("Puissance de démarrage");
    device_dimmer_starting_pow.Set_object_id("starting_power");
    device_dimmer_starting_pow.Set_entity_type("number");
    device_dimmer_starting_pow.Set_entity_category("config");
    device_dimmer_starting_pow.Set_entity_valuemin("-100");
    device_dimmer_starting_pow.Set_entity_valuemax("500"); // trop? pas assez? TODO : test sans valeur max?
    device_dimmer_starting_pow.Set_entity_valuestep("1");
    device_dimmer_starting_pow.Set_retain_flag(true);

    device_dimmer_minpow.Set_name("Puissance mini");
    device_dimmer_minpow.Set_object_id("minpow");
    device_dimmer_minpow.Set_entity_type("number");
    device_dimmer_minpow.Set_entity_category("config");
    device_dimmer_minpow.Set_entity_valuemin("0");
    device_dimmer_minpow.Set_entity_valuemax("100"); // trop? pas assez? TODO : test sans valeur max?
    device_dimmer_minpow.Set_entity_valuestep("1");
    device_dimmer_minpow.Set_retain_flag(true);

    device_dimmer_maxpow.Set_name("Puissance maxi");
    device_dimmer_maxpow.Set_object_id("maxpow");
    device_dimmer_maxpow.Set_entity_type("number");
    device_dimmer_maxpow.Set_entity_category("config");
    device_dimmer_maxpow.Set_entity_valuemin("0");
    device_dimmer_maxpow.Set_entity_valuemax("100"); // trop? pas assez? TODO : test sans valeur max?
    device_dimmer_maxpow.Set_entity_valuestep("1");
    device_dimmer_maxpow.Set_retain_flag(true);

    device_dimmer_maxtemp.Set_name("Température maxi");
    device_dimmer_maxtemp.Set_object_id("maxtemp");
    device_dimmer_maxtemp.Set_entity_type("number");
    device_dimmer_maxtemp.Set_entity_category("config");
    device_dimmer_maxtemp.Set_entity_valuemin("0");
    device_dimmer_maxtemp.Set_entity_valuemax("75"); // trop? pas assez? TODO : test sans valeur max?
    device_dimmer_maxtemp.Set_entity_valuestep("1");
    device_dimmer_maxtemp.Set_retain_flag(true);
    /// création des select
    device_dimmer_child_mode.Set_name("Mode");
    device_dimmer_child_mode.Set_object_id("child_mode");
    device_dimmer_child_mode.Set_entity_type("select");
    device_dimmer_child_mode.Set_entity_category("config");
    device_dimmer_child_mode.Set_entity_option("\"off\",\"delester\",\"equal\"");
    device_dimmer_child_mode.Set_retain_flag(true);

    // création des binary_sensor
    device_dimmer_alarm_temp.Set_name("Surchauffe");
    device_dimmer_alarm_temp.Set_object_id("alarm_temp");
    device_dimmer_alarm_temp.Set_entity_type("binary_sensor");
    device_dimmer_alarm_temp.Set_entity_category("diagnostic");
    device_dimmer_alarm_temp.Set_dev_cla("problem");
    device_dimmer_alarm_temp.Set_retain_flag(true);

    device_cooler.Set_name("Ventillateur");
    device_cooler.Set_object_id("cooler");
    device_cooler.Set_entity_type("binary_sensor");
    device_cooler.Set_entity_category("diagnostic");
    device_cooler.Set_dev_cla("running");
    device_cooler.Set_retain_flag(true);
  }

  //Serial.println(device_temp.name);
  /// MQTT 
  if (!AP && mqtt_config.mqtt) {
    Serial.println("Connection MQTT" );
    loginit +="MQTT connexion\r\n"; 
   // Serial.println(String(mqtt_config.username));
   // Serial.println(String(mqtt_config.password));

    client.setServer(config.hostname, config.port);
    client.setCallback(callback);
    reconnect();

    client.setBufferSize(512); // test bug MQTT
    if (config.HA) {
      device_dimmer_on_off.HA_discovery();
      device_dimmer.HA_discovery();
      device_cooler.HA_discovery();
      #ifdef RELAY1
        device_relay1.HA_discovery();
      #endif
      #ifdef RELAY2
        device_relay2.HA_discovery();
      #endif
    device_dimmer_starting_pow.HA_discovery();
    device_dimmer_minpow.HA_discovery();
    device_dimmer_maxpow.HA_discovery();
    device_dimmer_child_mode.HA_discovery();
    device_dimmer_save.HA_discovery();

    }
    if (config.HA || config.JEEDOM) {
    // device_dimmer_on_off.send(String(config.dimmer_on_off));
    device_dimmer.send(String(sysvar.puissance));
    device_cooler.send(stringboolMQTT(false));
    device_dimmer_starting_pow.send(String(config.startingpow));
    device_dimmer_minpow.send(String(config.minpow));
    device_dimmer_maxpow.send(String(config.maxpow));
    device_dimmer_child_mode.send(String(config.mode));
    }


  }
  
  #ifdef  SSR
  analogWriteFreq(GRIDFREQ) ; 
  analogWrite(JOTTA, 0);
  #endif



Serial.println(ESP.getFreeHeap());
}

bool alerte=false;

/// LOOP 
///
void loop() {

  if (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print("NO WIFI - Restarting Dimmer");
    ESP.restart();
  }

  if (!client.connected()) {
    reconnect();
  }
  client.loop();


  if (config.restart) {
    delay(5000);
    Serial.print("Restarting Dimmer");
    ESP.restart();
  }
  //// si la sécurité température est active 
  if ( security == 1 ) { 
      if (!alerte){
        Serial.println("Alert Temp");
        logs += "Alert Temp\r\n";
         
      
        if (!AP && mqtt_config.mqtt) { 
            Mqtt_send_DOMOTICZ(String(config.IDXAlarme), String("Alert Temp :" + String(sysvar.celsius) ));  ///send alert to MQTT
        }
        alerte=true;

      }
    //// Trigger
      if ( sysvar.celsius <= (config.maxtemp - (config.maxtemp*TRIGGER/100)) ) {  
        security = 0 ;
                if (!AP && mqtt_config.mqtt) { device_dimmer_alarm_temp.send(stringboolMQTT(security)); }
        sysvar.change = 1 ;
      }
      else {
      dimmer_off();
      }
  }
  else 
  {
    alerte=false;
  }



  /// Changement de la puissance (  pb de Exception 9 si call direct ) 
  if ( sysvar.change == 1  ) {
    sysvar.change = 0; 
    if (config.dimmer_on_off == 0){
      dimmer_off();  
    }
    if (sysvar.puissance > config.minpow && sysvar.puissance != 0 && security == 0) 
    {
        if (config.dimmer_on_off == 1){dimmer_on();}  // if off, switch on 

        if ( sysvar.puissance > config.maxpow )  
        { 
          if (config.dimmer_on_off == 1){
            dimmer.setPower(config.maxpow);
            #ifdef outputPin2
              dimmer2.setPower(config.maxpow);
            #endif
          }
          if ( strcmp(config.mode,"delester") == 0 ) { child_communication(sysvar.puissance-config.maxpow ); } // si mode délest, envoi du surplus
          if ( strcmp(config.mode,"equal") == 0) { child_communication(sysvar.puissance); }  //si mode equal envoie de la commande vers la carte fille

          #ifdef  SSR
          analogWrite(JOTTA, (config.maxpow*256/100) );
          #endif

        }
        else {
        if (config.dimmer_on_off == 1){
          dimmer.setPower(sysvar.puissance);
          #ifdef outputPin2
            dimmer2.setPower(sysvar.puissance);
          #endif
        }
          logs += "dimmer at " + String(sysvar.puissance) + "\r\n";
          if ( strcmp(config.mode,"equal") == 0) { child_communication(sysvar.puissance); }  //si mode equal envoie de la commande vers la carte fille
          #ifdef  SSR
          analogWrite(JOTTA, (sysvar.puissance*256/100) );
          #endif
        }

        /// cooler 
        if (config.dimmer_on_off == 1){
          if (!AP && mqtt_config.mqtt && digitalRead(COOLER) == LOW ) {device_cooler.send(stringboolMQTT(true));}
          digitalWrite(COOLER, HIGH); // start cooler 
          Timer_Cooler = millis();
          logs += "Start Cooler\r\n";
        }
        
      // if ( config.IDX != 0 ) {
      //   if ( sysvar.puissance > config.maxpow )  
      //   {
      //     Mqtt_send_DOMOTICZ(String(config.IDX), String(config.maxpow));  // remonté MQTT de la commande max
      //     //mqtt_HA (String(sysvar.celsius),String(config.maxpow));
      //     //device_dimmer.send(String(sysvar.puissance));
      //   }
      //   else 
      //   {
      //     Mqtt_send_DOMOTICZ(String(config.IDX), String(sysvar.puissance));  // remonté MQTT de la commande réelle
      //     //mqtt_HA (String(sysvar.celsius),String(sysvar.puissance));
      //     //device_dimmer.send(String(sysvar.puissance));
      //   }
        
      // }
      // //device_dimmer.send(String(puissance));


      if (!AP && mqtt_config.mqtt) { 
        if (config.dimmer_on_off == 0){
          Mqtt_send_DOMOTICZ(String(config.IDX), String("0"));  // remonté MQTT de la commande 0
          device_dimmer.send(String("0"));  // remonté MQTT HA de la commande 0
        }
        else if ( sysvar.puissance > config.maxpow ) {
          Mqtt_send_DOMOTICZ(String(config.IDX), String(config.maxpow));  // remonté MQTT de la commande max
          device_dimmer.send(String(config.maxpow));  // remonté MQTT HA de la commande max
        }
        else {
          Mqtt_send_DOMOTICZ(String(config.IDX), String(sysvar.puissance)); // remonté MQTT de la commande réelle
          device_dimmer.send(String(sysvar.puissance)); // remonté MQTT HA de la commande réelle
        }
      }
    

    }
    else if (sysvar.puissance > config.minpow && sysvar.puissance != 0 && security == 1)
    {
      if ( strcmp(config.mode,"delester") == 0 ) { child_communication(sysvar.puissance ); } // si mode délest, envoi du surplus
      if ( strcmp(config.mode,"equal") == 0) { child_communication(sysvar.puissance); }  //si mode equal envoie de la commande vers la carte fille
    }
    else {
        //// si la commande est trop faible on coupe tout partout
        dimmer.setPower(0);
        #ifdef outputPin2
          dimmer2.setPower(0);
        #endif
        dimmer_off();  
        if ( strcmp(config.mode,"off") != 0) { child_communication(0); }

          #ifdef  SSR
          analogWrite(JOTTA, 0 );
          #endif

        //   if ( config.IDX != 0 ) { Mqtt_send_DOMOTICZ(String(config.IDX), String(0)); }
        // //mqtt_HA (String(sysvar.celsius),String(sysvar.puissance));
        // //device_dimmer.send(String(sysvar.puissance));
        // Mqtt_send_DOMOTICZ(String(config.IDX), String(sysvar.puissance));
    

      if (!AP && mqtt_config.Mqtt::mqtt) {
        Mqtt_send_DOMOTICZ(String(config.IDX), String(sysvar.puissance));
        device_dimmer.send(String(sysvar.puissance));
        // if ( (millis() - Timer_Cooler) > (TIMERDELAY * 1000) ) { digitalWrite(COOLER, LOW); }  // cut cooler 
      }
      if ( (millis() - Timer_Cooler) > (TIMERDELAY * 1000) && digitalRead(COOLER) == HIGH ) {   // cut cooler 
        digitalWrite(COOLER, LOW); 
        if (!AP && mqtt_config.mqtt) { device_cooler.send(stringboolMQTT(false));}
}
    }
  }
if ( ((millis() - Timer_Cooler) > (TIMERDELAY * 1000) ) && (sysvar.puissance < config.minpow) && digitalRead(COOLER) == HIGH ) {   // cut cooler 
  digitalWrite(COOLER, LOW); 
  if (!AP && mqtt_config.mqtt) { device_cooler.send(stringboolMQTT(false));}
}

 ///// dallas présent >> mesure 
  if ( present == 1 ) { 
    refreshcount ++;

    if (refreshcount == 1 ) {
    sensors.requestTemperatures();
    sysvar.celsius=CheckTemperature("Inside : ", addr); 
    }

    //gestion des erreurs DS18B20
    if ( (sysvar.celsius == -127.00) || (sysvar.celsius == -255.00) ) {
      sysvar.celsius=previous_celsius;
    }
    else {
      sysvar.celsius=(floor(10*sysvar.celsius+0.5))/10; // arrondi 1 décimale
    }   

    if ( refreshcount >= refresh && sysvar.celsius !=-127 && sysvar.celsius !=-255) { 
      
    if (!AP && mqtt_config.mqtt) {

       Mqtt_send_DOMOTICZ(String(config.IDXTemp), String(sysvar.celsius));  /// remonté MQTT de la température
      //mqtt_HA (String(sysvar.celsius),String(sysvar.puissance));
      //device_temp.send(String(sysvar.celsius));
      if (!discovery_temp) {
        discovery_temp = true;
        device_dimmer_alarm_temp.HA_discovery();
        device_temp.HA_discovery();
        device_dimmer_maxtemp.HA_discovery();
        device_dimmer_alarm_temp.send(stringboolMQTT(security));
        device_dimmer_maxtemp.send(String(config.maxtemp));
        
      }
      device_temp.send(String(sysvar.celsius));

    }
      refreshcount = 0; 
    } 
  
    previous_celsius=sysvar.celsius;
    // delay(500);  /// suppression 24/01/2023 pour plus de rapidité
  } 

    //***********************************
    //************* LOOP - Activation de la sécurité
    //***********************************
if ( sysvar.celsius >= config.maxtemp && security == 0 ) {
  security = 1 ; 
  if ( strcmp(config.mode,"delester") == 0 ) { child_communication(sysvar.puissance ); } // si mode délest, envoi du surplus
  if (!AP && mqtt_config.mqtt) { device_dimmer_alarm_temp.send(stringboolMQTT(security)); }
}

 delay(100);  // 24/01/2023 changement 500 à 100ms pour plus de réactivité
}

///////////////
////fin de loop 
//////////////


    //***********************************
    //************* récupération d'une température du 18b20
    //***********************************

float CheckTemperature(String label, byte deviceAddress[12]){
  float tempC = sensors.getTempC(deviceAddress);
  Serial.print(label);
  if ( (tempC == -127.00) || (tempC == -255.00) ) {
    Serial.print("Error getting temperature");
    logs += "Dallas on error\r\n";
  } else {
    Serial.print(" Temp C: ");
    Serial.println(tempC);
    // logs += "Dallas temp : "+ String(tempC) +"\r\n";
    return (tempC); 
   
    
  }  
  return (tempC); 
}


    //***********************************
    //************* Test de la présence d'une 18b20 
    //***********************************

void dallaspresent () {

if ( !ds.search(addr)) {
    Serial.println("Dallas not connected");
    loginit += "Dallas not connected\r\n";
    Serial.println();
    ds.reset_search();
    delay(250);
    return ;
  }
  
  Serial.print("ROM =");
  for( i = 0; i < 8; i++) {
    Serial.write(' ');
    Serial.print(addr[i], HEX);
  }

   Serial.println();
 
  // the first ROM byte indicates which chip
  switch (addr[0]) {
    case 0x10:
      Serial.println("  Chip = DS18S20");  // or old DS1820
      type_s = 1;
      break;
    case 0x28:
      Serial.println("  Chip = DS18B20");
      type_s = 0;
      break;
    case 0x22:
      Serial.println("  Chip = DS1822");
      type_s = 0;
      break;
    default:
      Serial.println("Device is not a DS18x20 family device.");
      return ;
  } 

  ds.reset();
  ds.select(addr);

  ds.write(0x44, 1);        // start conversion, with parasite power on at the end
  
  delay(1000);     // maybe 750ms is enough, maybe not
  // we might do a ds.depower() here, but the reset will take care of it.
  
  present = ds.reset();    ///  byte 0 > 1 si present
  ds.select(addr);    
  ds.write(0xBE);         // Read Scratchpad

  Serial.print("  present = ");
  Serial.println(present, HEX);
  loginit += "Dallas present at "+ String(present, HEX) + "\r\n";

  return ;
   
  }

/// affichage de logs 
String getlogs(){
    logs = logs + loginit + "}1"; 
    loginit = "";
  
    return logs ; 
} 


/// @brief beta 
void handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){
  if(!index){
    Serial.printf("UploadStart: %s\n", filename.c_str());
  }
  for(size_t i=0; i<len; i++){
    Serial.write(data[i]);
  }
  if(final){
    Serial.printf("UploadEnd: %s, %u B\n", filename.c_str(), index+len);
  }
}

void merge(JsonObject dest, JsonObjectConst src)
{
   for (JsonPairConst kvp : src)
   {
     dest[kvp.key()] = kvp.value();
   }
}
